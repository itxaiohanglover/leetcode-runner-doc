---
title: 各语言的常见写法
date: 2025-03-31 8:08:34
permalink: /pages/0x3f/
---

# 写给读者
各个语言都会有些常见的但写起来比较操蛋的内容，本文做一个集中记录，方便读者笔试前统一复习

另外，我推荐各位读者掌握`python`，`java`，`c++`这三种语言的基础语法。可能你未来主要从事Java行业，但我也推荐你学会这三种语言。

就拿最实际的来说吧，一般大公司都会有一轮笔试，笔试时间珍贵，你要在最短的时间内把题目做出来。这时候`python`简洁的语法优势就会显示出来，你可以在更短的时间写出代码，为你做后续题目节省时间。

BUT，python的运行效率是低于`c++`的，因此对于某些卡时间复杂度的题目，可以选择`c++`暴力破解。

那么啥时候推荐使用`java`呢？在我看来，**遇到一些字符串处理的题目，Java相较于python还是占优的**。一方面java没有c++那么复杂，另一方面在字符串API上除了**切片**功能，大部分情况下**我个人认为java比python**好用，比如python是无法做出`'a' + 1`这样的操作，这就显得格外蛋疼了。

## Java

### 自定义排序

**数组排序**
```java
int[] a = new int[]{3,2,1};
Arrays.sort(a);
// 升序a 排序后变成 {1,2,3}
```

**List排序**
```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(2);
list.add(1);
Collections.sort(list); // list.sort();
// 升序list 排序后变成 {1,2,3}
```

**List自定义排序**
```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(2);
list.add(1);
list.sort((Integer a, Integer b) -> {
    return Integer.compare(a, b);
});
```
> tip
> 有的同学可能总是忘记自定义的lambda表达式该咋写，这有个小技巧。首先，List的泛型是什么，lambda的两个参数类型就是啥
> 其次，如果不知道怎么写是升序，怎么写是降序，只需要记住**左边在左边，右边在右边**，这就是`升序`。就比如lambda的入参是a，b。在return处a(左边的)在左边，b(右边的)在右边，最终会实现升序效果。如果需要降序，前面加个`-`即可


## Python

### 排序
**列表排序**
```python
a = [3, 1, 2]
a.sort()  # 原地排序，升序
# a变为[1, 2, 3]

b = sorted(a)  # 返回新列表，原列表不变
# b为[1, 2, 3], a保持不变
```

**降序排序**
```python
a.sort(reverse=True)  # 原地降序排序
b = sorted(a, reverse=True)  # 返回新降序列表
```

**自定义排序**
```python
# 按字符串长度排序
words = ['apple', 'banana', 'cherry']
words.sort(key=lambda x: len(x))
# 结果为['apple', 'cherry', 'banana']

# 多级排序
students = [('Tom', 20), ('Alice', 18), ('Bob', 20)]
students.sort(key=lambda x: (x[1], -x[0]))  # 先按年龄升序，再按姓名降序
```

### heapq
**导包**
```python
import heapq
```

**构建堆**
```python
a = [1,2,3]
heapq.heapify(a)
```

**插入元素**
```python
heapq.heappush(a, 4)  # 将元素4插入堆中
```

**弹出堆顶元素**
```python
min_val = heapq.heappop(a)  # 弹出并返回堆中的最小元素
```

**peek操作, 获取最小元素**
```python
min_val = a[0]  # 获取堆中的最小元素，但不弹出
```

> tip:
> 请注意，python的heapq默认提供的是最小堆，如果需要使用最大堆，请在为所有元素添加'-'号
> 例如: [1, 2, 3] -> [-1, -2, -3]. 这样在构建heap的时候，依然会按照最小堆的规则构建，但弹出元素时会先把-3弹出来。去除负号后得到3


### 将数字变为二进制字符串
```python
num = 10  # 十进制数字
binary_str = bin(num)[2:]  # 转换为二进制字符串，去掉前缀'0b'
print(binary_str)  # 输出结果为 '1010'
```

### 字符通过ASCII码加整数
```python
chr(ord('a') + 1)
# 'b'
```

> `ord()`可以把字符转换为ASCII码

### map

#### 初始化
```python
# 初始化一个空的map
my_map = dict()
```

#### 将字典的键转换为列表

```python
d = {'a': 1, 'b': 2, 'c': 3}
keys_list = list(d.keys())
print(keys_list)  # 输出：['a', 'b', 'c']
```

#### 将字典的值转换为列表

```python
d = {'a': 1, 'b': 2, 'c': 3}
values_list = list(d.values())
print(values_list)  # 输出：[1, 2, 3]
```

#### 将字典的键值对转换为列表

```python
d = {'a': 1, 'b': 2, 'c': 3}
items_list = list(d.items())
print(items_list)  # 输出：[('a', 1), ('b', 2), ('c', 3)]
```

#### 遍历字典

```python
d = {'a': 1, 'b': 2, 'c': 3}
for key, value in d.items():
    print(key, value)
# 输出：
# a 1
# b 2
# c 3
```

## C++


### 数组排序

**升序**
```cpp
int a[] = {3, 1, 2};
int n = sizeof(a) / sizeof(a[0]);  // 计算数组长度
sort(a, a + n);  // 对数组进行排序，升序
// a变为{1, 2, 3}
```

**降序**
```cpp
int a[] = {3, 1, 2};
int n = sizeof(a) / sizeof(a[0]);  // 计算数组长度
sort(a, a + n, [](int x, int y) {
    return x > y;  // 使用lambda表达式实现降序
});
// a变为{3, 2, 1}
```

### vector排序

**升序**
```cpp
#include <vector>
#include <algorithm>

std::vector<int> vec = {3, 1, 2};
sort(vec.begin(), vec.end());  // 对vector进行排序，升序
// vec变为{1, 2, 3}
```

**降序**
```cpp
#include <vector>
#include <algorithm>

std::vector<int> vec = {3, 1, 2};
sort(vec.begin(), vec.end(), [](int x, int y) {
    return x > y;  // 使用lambda表达式实现降序
});
// vec变为{3, 2, 1}
```

### 复杂对象自定义排序
```cpp
struct Student {
    std::string name;
    int score;
};

std::vector<Student> students = {
    {"Alice", 88},
    {"Bob", 95},
    {"Charlie", 88},
    {"David", 72}
};

/**
 * 自定义排序规则：
 * 1. 按成绩降序
 * 2. 成绩相同时，按姓名字典序升序
 * 如果记不住lambda表达式咋写，可以记住左边在左边，右边在右边。小于号(<)，是升序；大于号(>)，是降序
 * 例如：return a.name < b.name;  左边(a)在左边，右边(b)在右边，加上小于号(<)，就是升序
 * 例如：return a.score > b.score;  左边(a)在左边，右边(b)在右边，加上大于号(>)，就是降序
 */
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    if (a.score != b.score) {
        return a.score > b.score;  // 按成绩降序
    }
    return a.name < b.name;  // 成绩相同时按姓名字典序升序
});

// 排序后的students：
// Bob (95)
// Alice (88)
// Charlie (88)
// David (72)
```