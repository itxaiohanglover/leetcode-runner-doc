---
title: 算法模板
date: 2025-03-30 23:08:34
permalink: /pages/7f76b7/
---

# 写给读者
做同一件事情积累很长时间，就能够看到改变，哪怕难以言说，但思维层次就是会发生转变！

# 基础篇

## 数组

### 二分整数
本质：`寻找问题的边界`

关键词：`在某个区间找一个数` `判断一个数是否合法`

基础版：
```java
int bsearch_0(int x) {            
    int l= 0, r = n - 1;                    
    while (l <= r) {                                   
        int mid = l+ (r - l >> 1);                
        if (nums[mid] == x) {                            
            return mid;                                    
        } else if (nums[mid] < x) {                      
            l= mid + 1;                                   
        } else {                                              
            r= mid - 1;                                  
        }                                                     
    }                                                         
    return -1;                                                
}                                                             
```
相信所有人闭着眼睛都能写出来，它是最基础的二分思想，边界条件考虑简单，这里就不在赘述。
***
模板一：
```java
int bsearch_1(int x){
    int l = 0, r = n - 1;
    while(l < r){
        int mid = l + r >> 1;
        if(nums[mid] >= x) r = mid;
        else l = mid + 1;
    }    
    return l;
}
```
- 查找有重复的数字：返回第一个元素的下标
- 查找不存在的数字：返回第一个大于查找元素的下标
- 记忆：`>=`

模板二：
```java
int bsearch_2(int x){
    int l = 0, r = n - 1;
    while(l < r){
    	// 加1的原因是防止死循环
        int mid = l + r + 1 >> 1;
        if(nums[mid] <= x) l = mid;
        else r = mid - 1;
    }   
    return l;
}
```
- 查找有重复的数字：返回最后一个元素的下标
- 查找不存在的数字：返回最后一个小于查找元素的最大元素的下标，可能左出界
- 记忆：`<=`

步骤：
1. 确定二分的边界  [l, r]
2. 确定二分条件 + 模板（思考过程：要左边，那我就把right往左移动，要右边，那我就把left往右移动，left移动时可能会出现死循环）
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ab2643bdb9f63eb3471a08622a71d2df.png)

如果困惑 `模板二` 死循环的由来：大白话讲解就是   
- 挪动左：01查找0，mid一直是0，l一直0，r一直是1，l一直小于r，一直循环。
- 挪动右：01查找0，mid是0，r将会从1挪到0，l = 0，r==l结束循环了。

***
谈谈我对 while(l < r)、 while(l <= r) 、 [l，r)、 [l，r] 的理解：

首先从列举每种情况：
- [l，r) 的含义： l >= r 区间无效
- [l，r] 的含义： l > r 区间无效
- while(l < r)的含义： l >= r 结束循环
- while(l <= r)的含义： l > r 结束循环 

我们对情况进行排列组合：
- [l，r)  + while(l < r)  区间无效时结束循环
- [l，r) + while(l <= r)  l == r 区间无效但进入了循环
- [l，r] +  while(l < r) l == r时结束循环，l == r这种情况不需要进入循环
- [l，r] + while(l <= r) 区间无效时结束循环

### 排序
> 何为排序？怎个遍历？排序标准？有时候找这个标准更重要，或者说是参考线，比如我们从生到死，时间是线性递增（x），每个阶段干什么事，便是标准。（y），有的人生一波三折，有的人生一帆风顺。我们取每个时间段的标准来衡量每个阶段的y称为考试，最后把每次考试结果归并为人生。
****
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6b0dd858fd9e485e9d68bae62095afa8.png)
常见排序动图：
![krahets-bubble-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/7122b8ad46a8b916f1cc302332ae6e3d.gif)
![krahets-insertion-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/661f0712d4250a822a9c4e481a062f8f.gif)
![krahets-selection-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/fb1f434c932646213b6f52349ca58624.gif)

![krahets-quick-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/8c6dd4b083c11c353536fbb78c907ea9.gif)

![krahets-merge-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/33e5ffb3d060fe51a8b155ed8f29a177.gif)

![krahets-heap-sort.gif](https://i-blog.csdnimg.cn/blog_migrate/646099550902ba943d083216ed8b3e59.gif)
#### 冒泡排序
模板：
```java
void bubbleSort(int[] nums) {
	int N = nums.length;
	for (int i = 0; i < N - 1; i++) {  
		for (int j = 0; j < N - i - 1; j++) { 
			if (nums[j] > nums[j + 1]) {
				int tmp = nums[j];
				nums[j] = nums[j + 1];
				nums[j + 1] = tmp;
			}
		}
	}
}
```
优化版的冒泡排序：
```java
void bubbleSort(int[] nums) {
	int N = nums.length;
	for (int i = 0; i < N - 1; i++) {
		boolean flag = false; // 初始化标志位
		for (int j = 0; j < N - i - 1; j++) {
			if (nums[j] > nums[j + 1]) {
				int tmp = nums[j];
				nums[j] = nums[j + 1];
				nums[j + 1] = tmp;
				flag = true;  // 记录交换元素
			}
		}
		if (!flag) break;     // 内循环未交换任何元素，则跳出
	}
}
```
#### 快速排序
```java
void quick_sort(int q[], int l, int r) {
	// 递归终止条件
    if(l >= r) return;
    // 设置两个指针：一个头的前一位，一个尾巴的后一位
    // 再设置一个基准值
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j){
    	// 从左往右找第一个比 x >= 的
        do i ++; while(q[i] < x);
        // 从右往左找第一个比 x <= 的
        do j --; while(q[j] > x);
        if(i < j) swap(q[i], q[j]); // 这里交换的实现上文已经给出
    }
    // 分区间递归调用
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
1.为什么是`do-while`，而不是`while`
```java
while(q[i] < x) i ++;
while(q[j] > x) j --;
// 当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 while 陷入死循环
// 让i，j在特殊情况下也做出变更，防止出现死循环
```
2.为什么不是 `q[i] <= x` 、`q[j] >= x`
```java
假设数组的值全部相等
do i ++; while(q[i] <= x); 
i会自增到数组r + 1，q[i]越界,虽然不会报错，但会一直死循环下去
```
3.`if(i < j) swap(q[i], q[j]);` 能否使用 `i <= j`
```java
无影响
```
4.边界情况分析，防止无限划分（n分成n,0）

#### 归并排序
「分」的阶段首先将序列一步步分解成小的子序列进行分段排序；
「治」的阶段则将分段有序的子序列合并在一起，使得整个序列变得有序。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bb39d8ebcd00d7008158c22325f3a132.png)

```java
// 合并两个有序子数组的函数
void merge(int[] q, int l, int mid, int r) {
    int k = 0, i = l, j = mid + 1;
    int[] tmp = new int[r - l + 1];
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    // 将左半部分剩余元素复制到临时数组
    while (i <= mid) tmp[k++] = q[i++];
    // 将右半部分剩余元素复制到临时数组
    while (j <= r) tmp[k++] = q[j++];
    // 将临时数组中的元素复制回原数组
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}

// 归并排序函数，用于递归分割数组
void mergeSort(int[] q, int l, int r) {
    // 递归终止条件：如果左边界大于等于右边界，说明区间只有一个元素或为空，无需排序
    if (l >= r) return;
    // 计算中间位置
    int mid = l + r >> 1;
    // 递归排序左半部分
    mergeSort(q, l, mid);
    // 递归排序右半部分
    mergeSort(q, mid + 1, r);
    // 合并两个有序的子数组
    merge(q, l, mid, r);
}
```

> tip
> 如果在面试时，被要求手搓归并排序，请不要慌，按照以下思路编写
> 1. 先写一个merge函数，把`两个有序数组`合并成`一个有序数组`
> 2. 再写一个mergeSort函数，把`数组`**递归拆分**

